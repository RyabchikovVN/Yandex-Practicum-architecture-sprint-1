# Проектная работа 1 спринта

## Задание №1

### Уровень 1. Проектирование

**Выбор фреймворка** 

Выбор фреймворка будет зависеть от:
1) Стека технологий текущих команд
2) Целесообразность перехода на новый фреймворк
3) Сильных и слабых сторон фреймворков

Будем исходить из того что:
1) Текущий проект небольшой
2) Команда знает только `React`
3) Финансов для найма разработчиков на других фреймворках нет
4) `React` нас полностью устраивает т.к его Преимущества это:
- Бесперебойная и стабильная производительность с использованием виртуального `DOM`
- Возможность повторного использования компонентов облегчает совместную работу, а также их повторное использование в других частях приложения
- Идеальная альтернатива написанию компонентов при использовании `React` Hook, поскольку она позволяет разработчикам писать компоненты без классов, а также позволяет легко учить `React`
- Общий процесс создания компонентов сценариев упрощается с использованием `JSX`, бесплатного расширения синтаксиса
- Инструменты разработки `React` полезны и продвинуты
- `React` ориентирован на `SEO`, а платформа поставляется с полным набором инструментов для разработчиков

### Уровень 2. Планирование изменений

В текущем проекте реализован функционал:
1) Авторизация/Регистрация пользователей(`../components/Login.js`, `../components/Register.js`,`../components/InfoTooltip.js`)
2) Просмотр/Редактирование профиля пользователей(`../components/EditProfilePopup.js`, `../components/EditAvatarPopup.js`, `../components/PopupWithForm`)
3) Просмотр/Загрузка/Удаление фотографий(`../components/AddPlacePopup.js`, `../components/Card.js`, `../components/ImagePopup.js`, `../components/PopupWithForm`)
4) Сбор/Учет лайков(`../components/Card.js`) 
5) Хедер/Футер(`../components/Header.js`, `../components/Footer.js`)

Исходя из этого можем выделить микросервисы(расположим в том порядке, как если бы это делалось с использованием паттерна `Strangler Fig` на реальном проекте):
1) `PhotoCard`, будет отвечать за:
    - Просмотр фотографий
    - Загрузка фотографий
    - Удаление фотографий
    - Сбор лайков
    - Учет лайков
2) `User`, будет отвечать за:
    - Просмотр профиля
    - Редактирование профиля
3) `Auth`, будет отвечать за:
    - Авторизацию пользователей
    - Регистрацию пользователей
4) `Shared`, будет отвечать за:
    - Хедер
    - Футер

Обоснование:

    - Первым в работу возмем отделение сервиса `PhotoCard`, т.к. после анализа было выявленно что:
        1. На эту часть монолита идет больше всего нагрузка т.к. используется больштм числом пользователей
        2. Медленная работа, много таймаутов из-за чего от пользователей идет большое кол-во обращений и негатива

    - Вторым в работу возьмем `User` потому что:
        1. Эта часть работает стабильно, но есть запросы от пользователей на развите функционала

    - В третью очередь `Auth`, выделии его в отдельный микрофронтенд потому что:
        1. Можно развивать отдельно 
        2. Впоследтсвии можно будет перейти на готовое решение, чтобы не тратить ресурсы на резработку

    - Последним будем разрабатывать сервис `Shared` потому что:
        1. Его будут использовать другие сервисы, 
        2. Не нужно будет копировать в каждый сервис
        3. Нужно поддерживать только в одном месте
        4. Впоследствии можно будет развивать независимо от других сервисов

Будем использовать подход `Webpack Module Federation` потому что:
    -  позволяет независимым приложениям использовать общий код во время выполнения. Команды, которые разрабатывают разные микрофронтенды, смогут получить доступ к коду друг друга до развёртывания.
    - основан на функции `lazy loading`. Она позволяет приложению загружать фрагменты кода по требованию. Это сокращает время первоначальной загрузки и помогает оптимизировать использование ресурсов.

### `P.S.` Вынес в микросфронтенды компоненты, которые посчитал нужным, все приложения собираются. Чтобы поднять приложение нужны знания по `React`, на данный момент таковы отсутствуют, времени чтобы вникнуть не хватает т.к. был очень сильный завал на работе и сейчас нагоняю упущенное


## Задание №2

### Планирование изменений

При анализе существующего монолитного решения было принять разделить его на следующие микросервисы:
1) `Notification`

    - сервис будет отвечать за отправку уведомлений на почту пользователя:
       - `Нотификация нового пользователя`

       - `Нотификация об изменении состояния заказа`

       - `Нотификация участника аукциона`

       - `Нотификация об изменении состояния заказа`

    - в бд можно хранить историю отправки `email`, но для этого нам необязательно хранить сущности, будет достаточно данных, полученных из брокера сообщений 

2) `Auth`
    
    - сервис будет отвечать за: `Регистрация пользователей`, `Аутентификация`, `Присвоение ролей`, `Нотификация нового пользователя`, `Валидация токена безопасности`, проверка `JWT` 

    - описание:
        1. Если пользователь еще не зарегистрирован в системе, предлагаем зарегистрироваться, после регистрации отправляем в брокер сообщений событие `Нотификация нового пользователя`

        2. На событие событие `Нотификация нового пользователя` реагирует сервис `Notification` и отправляет письмо пользователю(в котором будет ссылка на подтверждение почты), о том что нужно подвердить `email`, после подтверждения почты меняем поле `Пользователь.Активен`

        3. Если пользоваттель уже есть в системе, авторизуем, проверяем что `Пользователь.Активен`, если активен - проверяем роли, создаем `JWT` токен, если нет то просим пользователя подтвердить `email`

3) `User`

    - сервис будет отвечать за: `Сгенерировать отчёт активности пользователей`(доступно только администратору), `Редактирование профиля пользователя`, `Изменить услугу пользователя`, `Изменить товар пользователя`, `Удалить услугу пользователя`, `Удалить товар пользователя`, `Редактировать аукцион`, `Создать аукцион`
    - описание:
        1. Пользователь может зайти в свой профиль, обновить/добавить данные о себе

        2. Администратору доступен дополнительный функционал `Сгенерировать отчёт активности пользователей`

        3. Пользователь может: Создать/Редактировать/Удалить свою(й) услугу/товар/аукцион

4) `Basket`

    - сервис будет отвечать за: `Создание заказа`, `Редактирование заказа`, `Сохранение заказа`, `Подтверждение заказа`, `Размещение заказа`, `Отобразить все заказы`, `Фильтрация и сортировка результатов`, `Запросить статус операции`, `Инициировать платёжную операцию`, `Нотификация участника аукциона`

    - описание:
        1. Пользователь управляет своими заказами, может Создавать/Редактировать/Сохранять/Подтверждать

        2. Просматривать свои заказы - `Фильтрация и сортировка результатов`

        3. Оплатить заказ - `Инициировать платёжную операцию`
        
        4. При успешной ставке на аукционе будетт инициироваться `Нотификация участника аукциона`

5) `ProductCatalog`

    - сервис будет отвечать за: `Отобразить статистику заказов`, `Поиск товаров`, `Фильтрация и сортировка результатов`, `Добавить товар в профиль пользователя`, `Добавить товар в корзину`

    - описание:
        1. Пользователь может посмотреть статаситику заказов его товаров

        2. Пользователь может добавить уже существующий товар в свой профиль

        3. Пользователь может Добавить товар в свою корзину

        4. Пользователь может Искать/Фильтровать/Сортировать товары

6) `ServiceCatalog`

    - сервис будет отвечать за: `Отобразить статистику заказов`, `Поиск услуг`, `Фильтрация и сортировка результатов` , `Добавить услугу в профиль пользователя`, `Добавить услугу в корзину`

    - описание:
        1. Пользователь может посмотреть статаситику заказов его услуг

        2. Пользователь может добавить уже существующию услугу в свой профиль

        3. Пользователь может Добавить услугу в свою корзину

        4. Пользователь может Искать/Фильтровать/Сортировать услуги

7) `Support`

    - сервис будет отвечать за: `Регистрация заявки на апелляцию`, `Обновить статус заявки на апелляцию`. `Регистрация заявки на техподдержку`, `Обновление статуса заявки`, `Создать заявку на техподдержку`, `Создать заявку на апелляцию`, `Обновить статус заявки на апелляцию`

    - описание:
        1. Пользователь может создать заявку на техподдержку/аппеляцию

        2. Обновить статус заявки(закрыть если сотрудники ответили на его вопрос или отправить/запросить уточнение по его вопросу)

        3. Для администратора будет доступен дополнительный функционал: `Регистрация заявки на апелляцию`, `Регистрация заявки на техподдержку`

8) `Payment`

    - сервис будет отвечать за: `Определить способ оплаты`, `Сгенерировать отчёт по продажам`, `Учёт платёжной операции`, `Авторизация платёжной операции`, `Инициировать отмену транзакции`, `Предоставить список и статус операций`, `Предоставить статус операции`
    
    - описание:
        1. Пользователь может задать способ оплаты

        2. Пользователь может Сгенерировать отчет по продажам

        3. Работа с платежными операциями пользователя

9) `Auction`

    - сервис будет отвечать за: `Обработать новую заявку на аукцион`, `Обновление ставок аукциона`, `Фильтрация и сортировка результатов`, `Обновление ставок аукциона`, `Обновление статуса аукциона`
    
    - описание:
        1. Пользователь может сделать ставку на аукцион

        2. Пользователь может Искать/Фильтровать/Сортировать аукционы

### Технологии
При разработке будем использовать: БД -`PostgreSQL`, Бекэнд - `Django/Python`, Автоматизация развертывания, управление нагрузкой, масштабирование, окрестровка - `K8s`,
шина сообщений - `RabbitMQ`, фронтенд - `React/HTML/CSS`. 


### Один из пользовательских сценариев

- Покупка товаров:

 1) Пользователь переходит в каталог товаров (действие пользователя)

 2) Находит нужный товар

 3) Кликает добавить в корзину

 4) Проверяется что пользователь авторизован

    1) Если не авторизован, перенаправляем на страницу авторизации

    2) Если авторизован, продолжаем

    - представим, пользователь авторизован

 5) Товар резервируется на сервисе `ProductCatalog`

 6) Отправляется событие о добавлении товара

 7) Событие обрабатывает сервис `Basket` и добавляет товар в корзину

 8) Пользователь переходит в корзину

 9) Пользователь нажимает купить

 10) Сервис `Basket` отправляет запрос на сервис `ProductCatalog`, чтобы удостовериться что товар  действительно есть в наличии

 11) Сервис `ProductCatalog` возвращает ответ

 12)  Сервис `Basket` обрабатывает запрос

    1) Если товар по каким-то причинам закончился, выводим сообщение пользователю

    2) Если есть в наличии, продолжаем

    - представим, товар есть в наличии

 13) Перенаправляем пользователя на сервис `Payment`

 14) Пользователь выбирает один из способов оплаты

    - представим, выбрана оплата картой онлайн

 15) Пользователь подтверждает намерение приобрести товар

 16) Сервис `Payment` отправляет запрос на сервис `ProductCatalog`, зарезервирован ли товар

    1) если товар не зарезервирован, но есть в наличии - резервируем

    2) если товар не зарезервирован и нет в наличии, нам нужно будет уведомить пользователя

    3) товар зарезервирован

    - представим что товар зарезервирован

 17) Сервис `Payment` отправляет запрос на внешний/партнерский сервис, о попытве приобрести товар

 18) Внешний/партнерский проверяет, что карта действительна

 19) Сервис присылает ответ, что необходимо подтвердить платеж

 20) Пользователь подтверждает платеж

 21) Сервис `Payment` отправляет запрос на внешний/партнерский сервис, что платеж подтвержден

 22) Сервис `Payment` отправляет запрос на внешний/партнерский сервис о статусе платежа

 23) Внешний/партнерский отвечает, что платеж подтвержден

 24) Сервис `Payment` отправляет событие, что покупка совершена

 25) Сервис `Basket` обрабатывает событие

    1) очищает корзину

    2) добавляет заказ в историю заказов

 26) Сервис `Notification` принимает событие об успешной покупке

 27) Сервис `Notification` отправляет сообщение пользователю об успешной покупке











    